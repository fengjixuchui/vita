# 配置内核

## 交叉编译内核设置

![20190912_130203_71](image/20190912_130203_71.png)

![20190912_130817_40](image/20190912_130817_40.png)

* 通过环境变量指定使用交叉编译
* 两种方式，一种是命令执行的时候显示指定交叉编译器，一种是直接修改顶层Makefile

![20190912_155149_73](image/20190912_155149_73.png)

## 基本内核配置

![20190912_155411_20](image/20190912_155411_20.png)

.config 配置文件一定要有，且必须在内核顶层目录

* make oldconfig，从/boot分区找内核配置，其实就是找hosted系统的内核配置
* make menuconfig，图形化界面配置
* make ${ARCH}_config，内核提供对应平台的默认配置
* make allnoconfig，最小化配置

![20190912_155638_55](image/20190912_155638_55.png)

LFS一般都必须基于最小化配置

![20190912_155713_61](image/20190912_155713_61.png)

执行命令之后其实就在顶层目录生成一个.config配置文件，内容是酱紫的

![20190912_155802_17](image/20190912_155802_17.png)

boolean类似，字符串类型。下面依次配置一些内容

## 配置处理器

![20190912_160024_13](image/20190912_160024_13.png)

* x86一向都兼容，但是鼻祖intel在64位上傻逼了，被AMD抢走了64位（兼容32位）鼻祖称号，因为它不想继续兼容32位了
* 兼容，纯粹就是为了支持更多设备，但是性能确实很尴尬

![20190912_160233_30](image/20190912_160233_30.png)

![20190912_160250_64](image/20190912_160250_64.png)

![20190912_160517_59](image/20190912_160517_59.png)

反正比较新的都选这个就对了

这一选项针对x86系列的CPU使用更多的常规优化。如果你在上面一项选的是i386、i586之类的才选这个通用x86支持,如果你的CPU能够在上述"Processor family"中找到就别选。除了对上面你选择的X86 CPU进行优化，它还对更多类型X86 CPU的进行优化。这将会使内核在其他的X86 CPU上运行得更好。这个选项提供了对X86系列CPU最大的兼容性，用来支持一些少见的x86构架的CPU。如果你的CPU能够在上面的列表中找到，就里就不用选了。

![20190912_160751_13](image/20190912_160751_13.png)

选中多核心支持



## 配置内核支持模块

![20190912_160903_35](image/20190912_160903_35.png)

![20190912_161712_49](image/20190912_161712_49.png)

![20190912_161805_56](image/20190912_161805_56.png)


## 配置硬盘控制器驱动

硬盘驱动要考虑三方面

1.硬盘控制器接口
  * SATA使用PCI接口，挂在PCI总线
2. 与SCSI层关系
  * 在内河中SATA设备被实现为一个SCSI设备
3. 底层设备驱动

![20190912_162027_32](image/20190912_162027_32.png)

* 内核将SATA逻辑上分为两层

![20190912_162045_22](image/20190912_162045_22.png)

![20190912_162317_97](image/20190912_162317_97.png)

从内核配置选项上可以看出他们之间的依赖关系

![20190912_162345_79](image/20190912_162345_79.png)

![20190912_162429_62](image/20190912_162429_62.png)

![20190912_162454_61](image/20190912_162454_61.png)

![20190912_162623_64](image/20190912_162623_64.png)

![20190912_162517_48](image/20190912_162517_48.png)

![20190912_162724_42](image/20190912_162724_42.png)

![20190912_162539_36](image/20190912_162539_36.png)

![20190912_162907_35](image/20190912_162907_35.png)

![20190912_162942_63](image/20190912_162942_63.png)

![20190912_162958_57](image/20190912_162958_57.png)

开启多线程编译

![20190912_163156_90](image/20190912_163156_90.png)

```
  LD      arch/x86/boot/compressed/vmlinux
  ZOFFSET arch/x86/boot/zoffset.h
  OBJCOPY arch/x86/boot/vmlinux.bin
  AS      arch/x86/boot/header.o
  LD      arch/x86/boot/setup.elf
  OBJCOPY arch/x86/boot/setup.bin
  BUILD   arch/x86/boot/bzImage
Setup is 15036 bytes (padded to 15360 bytes).
System is 1324 kB
CRC 6bfab967
Kernel: arch/x86/boot/bzImage is ready  (#1)
root@vita:/vita/build/linux-3.7.4# ls arch/x86/boot/b
bioscall.S  bioscall.o  bitops.h    boot.h      bzImage     
root@vita:/vita/build/linux-3.7.4# ls arch/x86/boot/bzImage -alh
-rw-r--r-- 1 root root 1.4M Sep 13 00:32 arch/x86/boot/bzImage
root@vita:/vita/build/linux-3.7.4# SPEEDUP=" -j ${CORES}"^C
root@vita:/vita/build/linux-3.7.4# file arch/x86/boot/bzImage
arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 3.7.4 (root@vita) #1 SMP Fri Sep 13 00:32:37 CST 2019, RO-rootFS, swap_dev 0x1, Normal VGA
root@vita:/vita/build/linux-3.7.4#

```
### 测试新编译的内核

![20190912_163543_70](image/20190912_163543_70.png)

![20190912_163708_74](image/20190912_163708_74.png)

```
root@vita:/vita# cp /sysroot/boot/bzImage /boot/
```

拷贝到当前虚拟机的/boot分区下，修改启动项

首先让grub显示菜单项，修改/etc/default/grub注释掉GRUB_HIDDEN相关的条目

![20190912_164421_54](image/20190912_164421_54.png)

修改后保存，运行命令 update-grub即可更新/boot/grub/grub.conf

然后再修改/etc/grub/grub.conf，否则update-grub可能会删掉你添加的内容。

```
root@vita:/boot/grub# cat grub.cfg |grep vita -A4 -B2


menuentry "vita" {
	set root='(hd0,2)'
	linux /boot/bzImage root=/dev/sda2 ro
}

```

![20190912_164626_71](image/20190912_164626_71.png)

修改配置，重启之后就可以看到

![20190912_164653_17](image/20190912_164653_17.png)

然而

![20190912_165326_82](image/20190912_165326_82.png)

这种方式肯定不行滴。。书上骚操作老版本系统呢吧

正确做法

![20190912_165705_20](image/20190912_165705_20.png)

拷贝一份默认Ubuntu的启动项，修改一下，应为如果grub没有ext2驱动，boot分区都找不到，更别说引导

修改后重启，即可实现书上的效果。没有挂在rootfs

![20190912_165758_70](image/20190912_165758_70.png)

![20190912_165302_31](image/20190912_165302_31.png)

## 配置文件系统

![20190912_172900_86](image/20190912_172900_86.png)

![20190912_170352_58](image/20190912_170352_58.png)

让内核支持ext4文件系统

![20190912_170442_25](image/20190912_170442_25.png)

启用2T+大容量支持


## 配置内核支持ELF文件格式

![20190912_170540_12](image/20190912_170540_12.png)

![20190912_171049_82](image/20190912_171049_82.png)

配置好后，重新编译内核，重新引导，还是老样子。因为没有解决根本原因。

![20190912_171320_18](image/20190912_171320_18.png)


为嘛我的还是显示不了？？因为漏了这个

![20190912_173056_69](image/20190912_173056_69.png) 

现在显示是找到磁盘，但是没有root挂载点

![20190912_171511_10](image/20190912_171511_10.png)

![20190912_171551_42](image/20190912_171551_42.png)

---
